## 随机森林和GBDT的区别

### 1. 随机森林

* 随机森林是一个用随机方式建立的，包含多个决策树的集成分类器。其输出的类别由各个树投票而定（如果是回归树则取平均）。假设样本总数为n，每个样本的特征数为a，则随机森林的**生成过程**如下：
  1. 从原始样本中采用有放回抽样的方法选取n个样本； 
  2. 对n个样本选取a个特征中的随机k个，用建立决策树的方法获得最佳分割点；
  3. 重复m次，获得m个决策树； 
  4. 对输入样例进行预测时，每个子树都产生一个结果，采用多数投票机制输出。

随机森林的**随机性**主要体现在两个方面：

1. 数据集的随机选取：从原始的数据集中采取有放回的抽样（bagging），构造子数据集，子数据集的数据量是和原始数据集相同的。不同子数据集的元素可以重复，同一个子数据集中的元素也可以重复。
2. 待选特征的随机选取：与数据集的随机选取类似，随机森林中的子树的每一个分裂过程并未用到所有的待选特征，而是从所有的待选特征中随机选取一定的特征，之后再在随机选取的特征中选取最优的特征。

以上两个随机性能够使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。

随机森林的**优点**：

1. 实现简单，训练速度快，泛化能力强，可以并行实现，因为训练时树与树之间是相互独立的；
2. 相比单一决策树，能学习到特征之间的相互影响，且不容易过拟合；
3. 能处理高维数据（即特征很多），并且不用做特征选择，因为特征子集是随机选取的；
4. 对于不平衡的数据集，可以平衡误差；
5. 相比SVM，不是很怕特征缺失，因为待选特征也是随机选取；
6. 训练完成后可以给出哪些特征比较重要。

随机森林的**缺点**：

1. 在噪声过大的分类和回归问题还是容易过拟合；
2. 相比于单一决策树，它的随机性让我们难以对模型进行解释。



### 2. GBDT （Gradient Boost Decision Tree 梯度提升决策树）

* GBDT是以决策树为基学习器的迭代算法，注意
* GBDT里的决策树都是回归树而不是分类树。
* Boost是”提升”的意思，一般Boosting算法都是一个迭代的过程，每一次新的训练都是为了改进上一次的结果。 
* GBDT的核心就在于：每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学习。 

* GBDT优点是适用面广，离散或连续的数据都可以处理，几乎可用于所有回归问题（线性/非线性），亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）。缺点是由于弱分类器的串行依赖，导致难以并行训练数据。



### 3. 随机森林和GBDT的区别

1. 随机森林采用的bagging思想，而GBDT采用的boosting思想。这两种方法都是Bootstrap思想的应用，Bootstrap是一种有放回的抽样方法思想。虽然都是有放回的抽样，但二者的区别在于：
   * Bagging采用有放回的均匀取样，而Boosting根据错误率来取样（Boosting初始化时对每一个训练样例赋相等的权重1／n，然后用该算法对训练集训练t轮，每次训练后，对训练失败的样例赋以较大的权重）Boosting的分类精度要优于Bagging。
   * Bagging的训练集的选择是随机的，各训练集之间相互独立，弱分类器可并行，而Boosting的训练集的选择与前一轮的学习结果有关，是串行的。

2. 组成随机森林的树可以是分类树，也可以是回归树；而GBDT只能由回归树组成。

3. 组成随机森林的树可以并行生成；而GBDT只能是串行生成。

4. 对于最终的输出结果而言，随机森林采用多数投票等；而GBDT则是将所有结果累加起来，或者加权累加起来。

5. 随机森林对异常值不敏感；GBDT对异常值非常敏感。

6. 随机森林对训练集一视同仁；GBDT是基于权值的弱分类器的集成。

7. 随机森林是通过减少模型方差提高性能；GBDT是通过减少模型偏差提高性能。